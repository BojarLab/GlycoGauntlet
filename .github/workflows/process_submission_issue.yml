name: Process Submission from Issue

on:
  issues:
    types: [opened]

jobs:
  process:
    if: startsWith(github.event.issue.title, '[Submission]')
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: write
      pull-requests: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
      
      - name: Extract username
        id: extract
        run: |
          USERNAME=$(echo "${{ github.event.issue.body }}" | grep -A2 "GitHub Username" | tail -1 | xargs)
          if [ -z "$USERNAME" ]; then
            echo "Failed to extract username, using issue creator"
            USERNAME="${{ github.event.issue.user.login }}"
          fi
          echo "username=$USERNAME" >> $GITHUB_OUTPUT
          echo "Extracted username: $USERNAME"
      
      - name: Download attachments
        id: download
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const https = require('https');
            const issue = context.payload.issue;
            const publicSection = issue.body.match(/### Public Test Predictions\s+([\s\S]*?)###/);
            const privateSection = issue.body.match(/### Private Test Predictions\s+([\s\S]*?)###/);
            const attachmentRegex = /https:\/\/github\.com\/.*?\/files\/\d+\/[^\s)]+\.csv/g;
            const rawUrlRegex = /https:\/\/raw\.githubusercontent\.com\/[^\s)]+\.csv/g;
            const publicRawUrls = publicSection ? (publicSection[1].match(rawUrlRegex) || []) : [];
            const privateRawUrls = privateSection ? (privateSection[1].match(rawUrlRegex) || []) : [];
            const publicUrls = publicSection ? ([...(publicSection[1].match(attachmentRegex) || []), ...publicRawUrls]) : [];
            const privateUrls = privateSection ? ([...(privateSection[1].match(attachmentRegex) || []), ...privateRawUrls]) : [];
            const extractBase64Files = (section) => {
              if (!section) return [];
              const fileRegex = /\*\*(.+?\.csv)\*\*:\s*```csv-base64\s+([\s\S]+?)```/g;
              const files = [];
              let match;
              while ((match = fileRegex.exec(section)) !== null) {
                files.push({name: match[1], content: match[2].trim()});
              }
              return files;
            };
            const publicBase64 = publicSection ? extractBase64Files(publicSection[1]) : [];
            const privateBase64 = privateSection ? extractBase64Files(privateSection[1]) : [];
            if (publicUrls.length === 0 && privateUrls.length === 0 && publicBase64.length === 0 && privateBase64.length === 0) {
              core.setFailed('No CSV attachments or base64 files found');
              return;
            }
            const downloadFile = async (url, dir) => {
              const filename = path.basename(url.split('?')[0]);
              await new Promise((resolve, reject) => {
                https.get(url, {followAllRedirects: true}, (response) => {
                  if (response.statusCode === 302 || response.statusCode === 301) {
                    https.get(response.headers.location, (finalResponse) => {
                      const file = fs.createWriteStream(path.join(dir, filename));
                      finalResponse.pipe(file);
                      file.on('finish', () => file.close(resolve));
                    }).on('error', reject);
                  } else {
                    const file = fs.createWriteStream(path.join(dir, filename));
                    response.pipe(file);
                    file.on('finish', () => file.close(resolve));
                  }
                }).on('error', reject);
              });
            };
            fs.mkdirSync('temp_submissions/public', {recursive: true});
            fs.mkdirSync('temp_submissions/private', {recursive: true});
            for (const url of publicUrls) {
              await downloadFile(url, 'temp_submissions/public');
            }
            for (const url of privateUrls) {
              await downloadFile(url, 'temp_submissions/private');
            }
            for (const file of publicBase64) {
              const decoded = Buffer.from(file.content, 'base64').toString('utf-8');
              fs.writeFileSync(path.join('temp_submissions/public', file.name), decoded);
            }
            for (const file of privateBase64) {
              const decoded = Buffer.from(file.content, 'base64').toString('utf-8');
              fs.writeFileSync(path.join('temp_submissions/private', file.name), decoded);
            }
            core.setOutput('has_public', publicUrls.length > 0 || publicBase64.length > 0);
            core.setOutput('has_private', privateUrls.length > 0 || privateBase64.length > 0);
            return publicUrls.length + privateUrls.length + publicBase64.length + privateBase64.length;
      
      - name: Create submission structure
        run: |
          mkdir -p submissions/${{ steps.extract.outputs.username }}/public
          mkdir -p submissions/${{ steps.extract.outputs.username }}/private
          if [ -d temp_submissions/public ] && [ "$(ls -A temp_submissions/public)" ]; then
            mv temp_submissions/public/*.csv submissions/${{ steps.extract.outputs.username }}/public/ || true
          fi
          if [ -d temp_submissions/private ] && [ "$(ls -A temp_submissions/private)" ]; then
            mv temp_submissions/private/*.csv submissions/${{ steps.extract.outputs.username }}/private/ || true
          fi
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Install dependencies
        run: |
          pip install pandas openpyxl
      
      - name: Validate format
        id: validate
        run: |
          if [ "${{ steps.download.outputs.has_public }}" == "true" ]; then
            python validation/check_format.py submissions/${{ steps.extract.outputs.username }}/public || echo "validation_failed=true" >> $GITHUB_OUTPUT
          fi
      
      - name: Evaluate submission
        if: steps.validate.outputs.validation_failed != 'true' && steps.download.outputs.has_public == 'true'
        id: evaluate
        run: |
          pip install pandas numpy scipy openpyxl glycowork
          RESULT=$(python evaluation/evaluate_submission.py submissions/${{ steps.extract.outputs.username }}/public)
          SCORE=$(echo "$RESULT" | grep "Average F1:" | awk '{print $3}')
          echo "score=$SCORE" >> $GITHUB_OUTPUT
          echo "$RESULT" > eval_result.txt
      
      - name: Update leaderboard
        if: steps.validate.outputs.validation_failed != 'true' && steps.download.outputs.has_public == 'true'
        run: |
          python leaderboard/update_leaderboard.py \
            "${{ steps.extract.outputs.username }}" \
            "${{ steps.evaluate.outputs.score }}" \
            "public"
      
      - name: Commit changes
        if: steps.validate.outputs.validation_failed != 'true'
        run: |
          git config user.name "Competition Bot"
          git config user.email "bot@github.com"
          git add leaderboard/ submissions/
          git commit -m "Add submission from ${{ steps.extract.outputs.username }}" || echo "No changes"
          git push
      
      - name: Comment results on issue
        uses: actions/github-script@v6
        with:
          script: |
            const validation_failed = '${{ steps.validate.outputs.validation_failed }}' === 'true';
            const has_public = '${{ steps.download.outputs.has_public }}' === 'true';
            const has_private = '${{ steps.download.outputs.has_private }}' === 'true';
            let body;
            if (validation_failed) {
              body = '‚ùå Validation failed. Please check your file format and try again.';
            } else {
              let parts = [];
              if (has_public) {
                const fs = require('fs');
                const result = fs.readFileSync('eval_result.txt', 'utf8');
                parts.push(`## ‚úÖ Public Test Evaluated!\n\n\`\`\`\n${result}\n\`\`\`\n\nCheck the leaderboard: [leaderboard/public.md](https://github.com/${context.repo.owner}/${context.repo.repo}/blob/main/leaderboard/public.md)`);
              }
              if (has_private) {
                parts.push(`## üì¶ Private Test Files Received\n\nYour private test predictions have been stored and will be evaluated after the competition ends.`);
              }
              body = parts.join('\n\n');
            }
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });
            
      - name: Close issue
        if: steps.validate.outputs.validation_failed != 'true'
        uses: actions/github-script@v6
        with:
          script: |
            github.rest.issues.update({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'closed'
            });